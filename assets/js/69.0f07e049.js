(window.webpackJsonp=window.webpackJsonp||[]).push([[69],{248:function(t,e,a){"use strict";a.r(e);var r=a(6),s=Object(r.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h4",{attrs:{id:"js-function-this的作用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#js-function-this的作用"}},[t._v("#")]),t._v(" js function this的作用")]),t._v(" "),a("h4",{attrs:{id:"react-class类组件的写法到底是什么意思-https-segmentfault-com-a-1190000003046071"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-class类组件的写法到底是什么意思-https-segmentfault-com-a-1190000003046071"}},[t._v("#")]),t._v(" React class类组件的写法到底是什么意思：https://segmentfault.com/a/1190000003046071")]),t._v(" "),a("ol",[a("li",[t._v("普通函数调用")]),t._v(" "),a("li",[t._v("作为对象的方法")]),t._v(" "),a("li",[t._v("作为构造函数来调用")]),t._v(" "),a("li",[t._v("new 操作符，this指向新创建的对象")]),t._v(" "),a("li",[t._v("call/apply方法的调用")]),t._v(" "),a("li",[t._v("Function.prototype.bind()方法")]),t._v(" "),a("li",[t._v("Eval函数，该函数执行的时候，this绑定到当前作用域的对象上")]),t._v(" "),a("li",[t._v("箭头函数，this的值与创建箭头函数的上下文的this一致")])]),t._v(" "),a("h4",{attrs:{id:"render-函数在组件中的作用是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#render-函数在组件中的作用是什么"}},[t._v("#")]),t._v(" render()函数在组件中的作用是什么")]),t._v(" "),a("p",[t._v("render函数是react组件lifecycle的一部分，其中ReactDOM是一个类对象，它公开一个名为render的方法，将React JSX呈现到DOM中。\n一般情况下，我们可以在App中使用ReactDOM.render一次渲染顶级组件，所有其他组件将是顶级组件的子级")]),t._v(" "),a("h4",{attrs:{id:"react和react-dom的关系"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react和react-dom的关系"}},[t._v("#")]),t._v(" react和react-dom的关系")]),t._v(" "),a("p",[t._v("React在v0.14之前，是没有react-dom的，所有的功能都包含在react里。从v0.14(2015-10)开始，react才被拆分成react和react-dom。\n为什么要把react和react-dom分开呢？因为有了react-native。react只包含了Web和Mobile通用的核心部分，负责DOM操作的分到了react-dom中，负责Mobile的包含在了react-native中。")]),t._v(" "),a("p",[t._v("ReactDOM只做和浏览器或DOM相关的操作，例如ReactDOM.render()和ReactDOM.findDOMNode()，如果是服务器渲染，可以使用ReactDOM.renderToString()。除了这些以外的其他所有事情都是react做的。")]),t._v(" "),a("p",[t._v("（有些业务场景是没有dom的，就不需要使用dom的操作；关于dom的就放在dom里面，关于手机端的就放在native里，就是不同层级模块之间不能完全依赖）")]),t._v(" "),a("h4",{attrs:{id:"hashrouter-link-route之间的关系"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#hashrouter-link-route之间的关系"}},[t._v("#")]),t._v(" HashRouter, Link, Route之间的关系")]),t._v(" "),a("ol",[a("li",[t._v("Link是怎么切换路由的呢？就是通过this.props.history.push(path)来改变HashRouter中的pathname属性，进而驱动Route们进行重新渲染，再次匹配我们的路由，最终实现路由的切换。渲染\n成一个a标签，然后给一个点击事件，点击的时候更改HashRouter的状态，驱动重新渲染")]),t._v(" "),a("li",[t._v("HashRouter是一个大容器，它控制着他自己到底渲染成什么样子，它是通过window.location.hash。当HashRouter开始渲染的时候，就会拿自己身上的pathname属性跟它肚子里Route的path进行匹配，\n匹配上的话，就会渲染Route的component对应的组件")]),t._v(" "),a("li",[t._v("Redirect 就是改变HashRouter的state，驱动重新渲染")]),t._v(" "),a("li",[t._v("https://juejin.cn/post/6844903588603363341")])]),t._v(" "),a("h4",{attrs:{id:"state-props-context"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#state-props-context"}},[t._v("#")]),t._v(" state,props,context")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("state: 维护组件内部“产生数据”的信息")])]),t._v(" "),a("li",[a("p",[t._v("props: 维护组件外部“传入数据”的信息")])]),t._v(" "),a("li",[a("p",[t._v("context: 维护跨级组件信息的传递，把数据放在一个“全局的云端”，需要的地方直接拿来用就可以。但是耦合性高，安全性低，可以随意修改\n3.0 context属性的使用步骤\n3.1 【准备步骤】\n3.1.1 在产生参数的最顶级组件中，使用childContextTypes静态属性来定义需要放入全局参数的类型\n3.1.2 在父组件中，提供状态，来管理数据\n3.1.3 声明子组件获取全局参数的方式\nclass App {\nstatic childContextTypes = {\ntitle: ProTypes.string\n}\nstate = {\ntitle:'源码TV'\n}\ngetChildContext(){\nreturn {\ntitle: this.state.title\n}\n}\n}\n3.2 【使用步骤】\n3.2.1 在子组件中，使用contextTypes静态属性，声明获取父组件放入全局context中的参数类型\n3.2.2 在子组件需要的地方，获取全局参数this.context.全局属性名\nclass Child{\nstatic contextTypes = {\ntitle:ProTypes.string\n}\nrender(){\nreturn (\n")]),a("div",[t._v("{this.context.title}")]),t._v("\n)\n}\n}"),a("p")]),t._v(" "),a("li",[a("p",[t._v("传统应用的弊端就是，跨级数据传递就是用props，一级一级往下传，每层都必须准确的把数据往下传，")])])]),t._v(" "),a("h4",{attrs:{id:"redux"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redux"}},[t._v("#")]),t._v(" redux")]),t._v(" "),a("ol",[a("li",[t._v("store 相当于一个商店，里面有很多货架：维持应用的state、getState()、dispatch(action)、subscribe(listener)")])]),t._v(" "),a("h4",{attrs:{id:"react组件的渲染时机"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react组件的渲染时机"}},[t._v("#")]),t._v(" react组件的渲染时机")]),t._v(" "),a("ol",[a("li",[t._v("调用了setState，使得状态改变了")]),t._v(" "),a("li",[t._v("props发生了变化")]),t._v(" "),a("li")]),t._v(" "),a("h4",{attrs:{id:"recommend首页获取轮播图和歌单列表做缓存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#recommend首页获取轮播图和歌单列表做缓存"}},[t._v("#")]),t._v(" recommend首页获取轮播图和歌单列表做缓存")])])}),[],!1,null,null,null);e.default=s.exports}}]);