(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{245:function(t,e,a){"use strict";a.r(e);var s=a(6),r=Object(s.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h3",{attrs:{id:"更新的大概流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#更新的大概流程"}},[t._v("#")]),t._v(" 更新的大概流程")]),t._v(" "),a("p",[t._v("触发状态更新")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("|\n|\nv\n\n？\n\n|\n|\nv\n")])])]),a("p",[t._v("render阶段开始")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("|\n|\nv    \n")])])]),a("p",[t._v("commit阶段开始")]),t._v(" "),a("p",[t._v("其中，？都做了什么呢？")]),t._v(" "),a("hr"),t._v(" "),a("h3",{attrs:{id:"触发更新"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#触发更新"}},[t._v("#")]),t._v(" 触发更新")]),t._v(" "),a("ol",[a("li",[t._v("在React中，有如下方法可以触发状态更新：")])]),t._v(" "),a("ul",[a("li",[a("code",[t._v("ReactDOM.render")]),t._v("—— HostRoot")]),t._v(" "),a("li",[a("code",[t._v("this.setState")]),t._v("—— ClassComponent")]),t._v(" "),a("li",[a("code",[t._v("this.forceUpdate")]),t._v("—— ClassComponent")]),t._v(" "),a("li",[a("code",[t._v("useState")]),t._v("—— FunctionComponent")]),t._v(" "),a("li",[a("code",[t._v("useReducer")]),t._v("—— FunctionComponent")])]),t._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[t._v("这些方法调用的场景各不相同，他们是如何接入同一套状态更新机制的呢？")])]),t._v(" "),a("p",[t._v("答案是：每次状态更新都会创建一个保存更新状态相关内容的对象，我们叫他"),a("code",[t._v("Update")]),t._v("，在render阶段的beginWork中会根据"),a("code",[t._v("Update")]),t._v("计算新的"),a("code",[t._v("state")])]),t._v(" "),a("ol",{attrs:{start:"3"}},[a("li",[t._v("由于不同类型组件工作方式不同，所以存在两种不同结构的"),a("code",[t._v("Update")]),t._v("，其中"),a("code",[t._v("ClassComponent")]),t._v("与"),a("code",[t._v("HostRoot")]),t._v("共用一套"),a("code",[t._v("Update")]),t._v("结构，"),a("code",[t._v("FunctionComponent")]),t._v("单独使用一种"),a("code",[t._v("Update")]),t._v("结构。\n虽然他们的结构不同，但是他们的工作机制与工作流程大体相同")])]),t._v(" "),a("hr"),t._v(" "),a("h3",{attrs:{id:"update的结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#update的结构"}},[t._v("#")]),t._v(" Update的结构")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" update"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" Update"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n   eventTime"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 任务的时机")]),t._v("\n   lane"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 优先级相关，不同update的优先级可能是不同的")]),t._v("\n   suspenseConfig"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n   tag"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" UpdateState"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 更新的类型，包括UpdateState、ReplaceState、ForceUpdate、CaptureUpdate")]),t._v("\n   payload"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 更新挂载的数据，不同类型组件挂载的数据不同。对于ClassComponent，payload为this.setState的第一个传参，对于HostRoot，payload为ReactDOM.render的第一个传参")]),t._v("\n   callback"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 更新的回调函数")]),t._v("\n   \n   next"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 与其他update连接形成的链表")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n")])])]),a("hr"),t._v(" "),a("h3",{attrs:{id:"流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#流程"}},[t._v("#")]),t._v(" 流程")]),t._v(" "),a("ol",[a("li",[t._v("触发状态更新，根据不同场景调用不同的方法，这些不同的方法触发的更新会拥有不同的优先级")]),t._v(" "),a("li",[t._v("创建"),a("code",[t._v("Update")]),t._v("对象，对于"),a("code",[t._v("FunctionComponent")]),t._v("来说，就是在"),a("code",[t._v("dispatchAction")]),t._v("中创建"),a("code",[t._v("Update")]),t._v("对象")]),t._v(" "),a("li",[t._v("从fiber到root，调用"),a("code",[t._v("markUpdateLaneFromFiberToRoot")]),t._v("，从触发更新的fiber一直向上遍历到"),a("code",[t._v("rootFiber")]),t._v("，并返回"),a("code",[t._v("rootFiber")]),t._v("，这样我们就得到了整个应用的根节点")]),t._v(" "),a("li",[t._v("调度整个应用的根节点，调用的方法是"),a("code",[t._v("ensureRootIsScheduled")])]),t._v(" "),a("li",[t._v("当调度的回调函数被执行时（调度的回调函数就是render阶段的起点），进入render阶段，在render阶段的"),a("code",[t._v("reconcile")]),t._v("函数中调用diff算法，会根据update对象返回对应的state，再用对应的state判断本次是否需要更新视图，如果需要被更新视图，就会被标记effectTag")]),t._v(" "),a("li",[t._v("接下来进入"),a("code",[t._v("commit阶段")]),t._v("，标记了"),a("code",[t._v("effectTag")]),t._v("的fiber就会执行对应的视图更新")])]),t._v(" "),a("hr"),t._v(" "),a("h3",{attrs:{id:"完整流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#完整流程"}},[t._v("#")]),t._v(" 完整流程")]),t._v(" "),a("p",[t._v("触发状态更新")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("|\n|\nv\n")])])]),a("p",[t._v("创建Update对象 -> 将update对象塞到updateQueue这个环状链表中 -> 从触发更新的fiber找到整个应用的根节点rootFiber -> 调度整个应用的根节点，判断是同步更新还是异步更新，同步的调用performSyncWorkOnRoot，异步的调用performConcurrentWorkOnRoot")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("|\n|\nv\n")])])]),a("p",[t._v("render阶段开始，在render阶段的reconciler，也就是diff算法中，根据update对象返回对应的state，再用对应的state判断本次是否需要更新视图，如果需要更新视图就会被打上effectTag")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("|\n|\nv    \n")])])]),a("p",[t._v("commit阶段开始，标记了effectTag的fiber就会执行对应的视图更新")]),t._v(" "),a("hr"),t._v(" "),a("h3",{attrs:{id:"更新流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#更新流程"}},[t._v("#")]),t._v(" 更新流程")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://raw.githubusercontent.com/superwtt/MyFileRepository/main/image/React/%E6%9B%B4%E6%96%B0%E6%B5%81%E7%A8%8B.png",alt:""}})]),t._v(" "),a("hr")])}),[],!1,null,null,null);e.default=r.exports}}]);