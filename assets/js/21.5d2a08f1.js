(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{236:function(t,a,e){"use strict";e.r(a);var s=e(6),n=Object(s.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h3",{attrs:{id:"背景"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#背景"}},[t._v("#")]),t._v(" 背景")]),t._v(" "),e("p",[t._v("上面两篇文章分别对应了首次渲染root不存在和第二次渲染root存在的两种情况。以及后续的render、commit流程")]),t._v(" "),e("p",[t._v("这边补充一下调度流程")]),t._v(" "),e("hr"),t._v(" "),e("h3",{attrs:{id:"为什么需要调度"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#为什么需要调度"}},[t._v("#")]),t._v(" 为什么需要调度")]),t._v(" "),e("ol",[e("li",[e("p",[t._v("大家都知道JS引擎和渲染引擎是一个互斥的关系，如果js在执行代码，那么渲染引擎工作就会被停止。如果我们有一个很复杂的复合组件需要重新渲染，那么调用栈很可能会很长。\n如果中间进行了复杂的操作，就可能导致长时间阻塞渲染引擎带来不好的用户体验，调度就是用来解决这个问题的。")])]),t._v(" "),e("li",[e("p",[t._v("React会根据任务的优先级去分配各自的"),e("code",[t._v("expirationTime")]),t._v("，在过期时间到来之前先去处理更高优先级的任务，并且高优先级的任务可以打断低优先级的任务，（因此会造成某些生命周期函数多次被执行），\n从而实现在不影响用户体验的情况下去分段计算更新，也就是时间分片")])])]),t._v(" "),e("hr"),t._v(" "),e("h3",{attrs:{id:"react如何实现调度"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react如何实现调度"}},[t._v("#")]),t._v(" React如何实现调度")]),t._v(" "),e("p",[t._v("React实现调度主要靠两个内容：")]),t._v(" "),e("ol",[e("li",[t._v("计算任务的"),e("code",[t._v("expriationTime")])]),t._v(" "),e("li",[t._v("实现"),e("code",[t._v("requestIdleCallback")]),t._v("的polyfill版本")])]),t._v(" "),e("h4",{attrs:{id:"expirationtime"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#expirationtime"}},[t._v("#")]),t._v(" expirationTime")]),t._v(" "),e("ol",[e("li",[t._v("如何计算的：\nexpirationTime = 当前时间+一个常量（根据任务的优先级改变）")])]),t._v(" "),e("p",[t._v("常量指的是根据不同优先级得出的一个数值，React内部目前总共有五种优先级，分别为：")]),t._v(" "),e("ul",[e("li",[e("code",[t._v("var ImmediatePriority = 1")])]),t._v(" "),e("li",[e("code",[t._v("var UserBlockingPriority = 2")])]),t._v(" "),e("li",[e("code",[t._v("var NormalPriority = 3")])]),t._v(" "),e("li",[e("code",[t._v("var LowPriority = 4")])]),t._v(" "),e("li",[e("code",[t._v("var IdlePriority = 5")])])]),t._v(" "),e("p",[t._v("它们各自对应的数值都是不同的，具体内容如下：")]),t._v(" "),e("ul",[e("li",[e("code",[t._v("var maxSigned31BitInt = 1073741823")])]),t._v(" "),e("li",[e("code",[t._v("var IMMEDIATE_PRIORITY_TIIMEOUT = -1")]),t._v(" // time out immediately")]),t._v(" "),e("li",[e("code",[t._v("var USER_BLOCKING_PRIORITY_TIMEOUT = -1")])]),t._v(" "),e("li",[e("code",[t._v("var NORMAL_PRIORITY_TIMEOUT = 250")])]),t._v(" "),e("li",[e("code",[t._v("var LOW_PRIORITY_TIMEOUT = 10000")])]),t._v(" "),e("li",[e("code",[t._v("var IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt")])])]),t._v(" "),e("p",[t._v("也就是说，假设当前时间为5000毫秒，并且分别有两个优先级不同的任务要执行。前者属于"),e("code",[t._v("ImmediatePriority")]),t._v("，后者属于"),e("code",[t._v("userBlockingPriority")]),t._v("，name两个任务计算出来的"),e("code",[t._v("expirationTime")]),t._v("分别为4999和5250.通过两者的时间对比大小可以得出谁的优先级高")]),t._v(" "),e("hr"),t._v(" "),e("h4",{attrs:{id:"requestidlecallback"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#requestidlecallback"}},[t._v("#")]),t._v(" requestIdleCallback")]),t._v(" "),e("p",[t._v("1.定义：React调度算法与"),e("code",[t._v("requestIdleCallback")]),t._v("这个api息息相关，"),e("code",[t._v("requestIdleCallback")]),t._v("的作用是，在浏览器一帧剩余空闲时间内执行优先度相对较低的任务，用法如下：")]),t._v(" "),e("div",{staticClass:"language-javascript extra-class"},[e("pre",{pre:!0,attrs:{class:"language-javascript"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" taskNum "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("10000")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("requestIdleCallback")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("unImportWork"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("unImportWork")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("deadline")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n   "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("deadline"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("timeRemaining")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v("taskNum "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n     console"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token template-string"}},[e("span",{pre:!0,attrs:{class:"token template-punctuation string"}},[t._v("`")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("执行了")]),e("span",{pre:!0,attrs:{class:"token interpolation"}},[e("span",{pre:!0,attrs:{class:"token interpolation-punctuation punctuation"}},[t._v("${")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("10000")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" tasksNum "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),e("span",{pre:!0,attrs:{class:"token interpolation-punctuation punctuation"}},[t._v("}")])]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("个任务")]),e("span",{pre:!0,attrs:{class:"token template-punctuation string"}},[t._v("`")])]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n     tasksNum"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),t._v("\n   "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" \n   "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("taskNum"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 在未来帧中继续执行")]),t._v("\n     "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("requestIdleCallback")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("unImportWork"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("   \n   "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),e("p",[t._v("2.缺点："),e("code",[t._v("requestIdleCallback")]),t._v("的FPS只有20，一般FPS为60时，对用户来说是流畅的，这远远低于页面流畅度的要求，所以React需要自己手动实现")]),t._v(" "),e("p",[t._v("3.如何实现："),e("code",[t._v("requestAnimationFrame + 计算帧时间以及下一帧时间 + MessageChannel")])]),t._v(" "),e("ul",[e("li",[e("p",[t._v("如何弥补"),e("code",[t._v("requestIdleCallback")]),t._v("的不足，能多次在浏览器空闲时且是渲染后才调用回调方法？说到多次执行，那么肯定得使用定时器了。在多种定时器中，唯有"),e("code",[t._v("requestAnimationFrame")]),t._v("具备一定的精确度，因此"),e("code",[t._v("requestAnimationFrame")]),t._v("就是当下实现"),e("code",[t._v("requestIdleCallback")]),t._v("的一个步骤。"),e("code",[t._v("requestAnimationFrame")]),t._v("的回调会在每次重绘之前执行")])]),t._v(" "),e("li",[e("p",[t._v("使用"),e("code",[t._v("requestAnimationFrame")]),t._v("只是实现了多次执行这一步操作，那么如何计算当前帧是否还有剩余时间让我们使用呢？假设当前时间为5000，浏览器支持60帧，那么1帧接近16毫秒，那么就会计算出下一帧的时间为5016.得出下一帧的时候以后，我们只需要对比当前时间是否小于下一帧时间即可，这样就能清楚地知道是否还有空闲时间去执行任务")])]),t._v(" "),e("li",[e("p",[t._v("如何在渲染以后才会执行任务？使用事件循环的知识")])])]),t._v(" "),e("hr"),t._v(" "),e("h3",{attrs:{id:"总结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("首先每个任务都有各自的优先级，通过当前时间加上优先级所对应的常量我们可以计算出"),e("code",[t._v("expriationTime")]),t._v("，高优先级的任务会打断低优先级的任务")])]),t._v(" "),e("li",[e("p",[t._v("在调度之前，判断当前任务是否过期，过期的话无须调度，直接调用"),e("code",[t._v("post.postMessage(undefind)")]),t._v("，这样就能在渲染后马上执行过期任务了")])]),t._v(" "),e("li",[e("p",[t._v("如果任务没有过期，就通过"),e("code",[t._v("requestAnimationFrame")]),t._v("启动定时器，在重绘前调用回调方法")])]),t._v(" "),e("li",[e("p",[t._v("在回调方法中，我们首先需要计算每一帧的时间以及下一帧的时间，然后执行"),e("code",[t._v("post.postMessage(undefined)")])])]),t._v(" "),e("li",[e("p",[e("code",[t._v("channel.port1.onmessage")]),t._v("会在渲染后被调用，在这个过程中，我们首先需要先去判断当前时间是否小于下一帧时间。如果小于的话就代表我们尚有空余时间去执行任务；如果大于的话就代表当前帧已经没有空闲时间了，这个时候我们需要去判断是否有任务过期，过期的话不管三七二十一一定还是得去执行这个任务。如果没有过期的话，只能把这个任务丢到下一帧看看能不能执行了")])])])])}),[],!1,null,null,null);a.default=n.exports}}]);