(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{240:function(e,t,r){"use strict";r.r(t);var v=r(6),_=Object(v.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h3",{attrs:{id:"react15架构"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#react15架构"}},[e._v("#")]),e._v(" React15架构")]),e._v(" "),r("p",[e._v("React15的架构可以分为两层：")]),e._v(" "),r("ul",[r("li",[e._v("Reconciler（协调器）——负责找出变化的组件")]),e._v(" "),r("li",[e._v("Renderer（渲染器）——负责将变化的组件渲染到页面上")])]),e._v(" "),r("hr"),e._v(" "),r("h4",{attrs:{id:"reconciler"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#reconciler"}},[e._v("#")]),e._v(" Reconciler")]),e._v(" "),r("p",[e._v("React中可以通过"),r("code",[e._v("this.setState")]),e._v("、"),r("code",[e._v("useState")]),e._v("、"),r("code",[e._v("this.forceUpdate")]),e._v("、"),r("code",[e._v("ReactDOM.render")]),e._v("等方式触发更新。")]),e._v(" "),r("p",[e._v("每当有更新发生时，Reconciler会做如下工作：")]),e._v(" "),r("ul",[r("li",[e._v("调用函数组件、或class组件的render方法，将返回的JSX转化为虚拟DOM")]),e._v(" "),r("li",[e._v("将虚拟DOM和上次更新时的虚拟DOM对比")]),e._v(" "),r("li",[e._v("通过对比找出本次更新中变化的虚拟DOM")]),e._v(" "),r("li",[e._v("通知Renderer将变化的虚拟DOM渲染到页面上")])]),e._v(" "),r("hr"),e._v(" "),r("h4",{attrs:{id:"renderer"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#renderer"}},[e._v("#")]),e._v(" Renderer")]),e._v(" "),r("p",[e._v("由于React支持跨平台，所以不同平台有不同的Renderer。我们前端最熟悉的是负责在浏览器环境渲染的Renderer——ReactDOM，除此之外，还有：")]),e._v(" "),r("ul",[r("li",[e._v("ReactNative渲染器，渲染App原生组件")]),e._v(" "),r("li",[e._v("ReactTest渲染器，渲染出纯JS对象用于测试")]),e._v(" "),r("li",[e._v("ReactArt渲染器，渲染到Canvas、SVG、VML")])]),e._v(" "),r("p",[e._v("在每次更新发生时，Renderer接到Reconciler通知，将变化的组件渲染在当前的宿主环境")]),e._v(" "),r("hr"),e._v(" "),r("h4",{attrs:{id:"react15架构的缺点"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#react15架构的缺点"}},[e._v("#")]),e._v(" React15架构的缺点")]),e._v(" "),r("p",[e._v("在React15的Reconciler中，"),r("code",[e._v("mount")]),e._v("的组件会调用"),r("code",[e._v("mountComponent")]),e._v("，"),r("code",[e._v("update")]),e._v("的组件会调用"),r("code",[e._v("updateComponent")]),e._v("。这两个方法都会递归更新子组件。")]),e._v(" "),r("p",[e._v("由于递归执行，所以更新一旦开始，中途就无法中断。当层级很深时，递归更新时间超过了16ms，用户交互就会卡顿。")]),e._v(" "),r("p",[e._v("React15架构不支持异步更新")]),e._v(" "),r("p",[e._v("例子：")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://raw.githubusercontent.com/superwtt/MyFileRepository/main/image/React/v15.png",alt:""}})]),e._v(" "),r("p",[e._v("我们可以看到，Reconciler和Renderer是交替工作的，当第一个li在页面上已经变化后，第二个li再进入Reconciler。")]),e._v(" "),r("p",[e._v("由于整个过程都是同步的，所以在用户看来所有的DOM都是同时更新的")]),e._v(" "),r("p",[e._v("接下来，我们模拟一下，如果中途中断更新会怎么样？")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://raw.githubusercontent.com/superwtt/MyFileRepository/main/image/React/dist.png",alt:""}})]),e._v(" "),r("p",[e._v("当第一个li完成更新时中断更新，即步骤3完成后中断更新，此时后面的步骤都还未执行")]),e._v(" "),r("p",[e._v("用户本来期望123变成246，实际却看见更新不完全的DOM，即223，")]),e._v(" "),r("p",[e._v("基于这个原因，React决定重写整个架构")]),e._v(" "),r("hr"),e._v(" "),r("h3",{attrs:{id:"react16架构"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#react16架构"}},[e._v("#")]),e._v(" React16架构")]),e._v(" "),r("p",[e._v("React16的架构可以分为三层：")]),e._v(" "),r("ul",[r("li",[e._v("Scheduler（调度器）—— 调度任务的优先级，高优先任务先进入Reconciler")]),e._v(" "),r("li",[e._v("Reconciler（协调器）—— 负责找出变化的组件，内部采用了Fiber架构")]),e._v(" "),r("li",[e._v("Renderer（渲染器）—— 负责将变化的组件渲染到页面上")])]),e._v(" "),r("p",[e._v("React16架构中整个更新流程为：")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://raw.githubusercontent.com/superwtt/MyFileRepository/main/image/React/process.png",alt:""}})]),e._v(" "),r("hr"),e._v(" "),r("h3",{attrs:{id:"自己总结"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#自己总结"}},[e._v("#")]),e._v(" 自己总结")]),e._v(" "),r("ol",[r("li",[e._v("React16相比React15架构多了一个调度器，用来调度任务的优先级")]),e._v(" "),r("li",[e._v("React16的Reconciler内部采用了Fiber架构")]),e._v(" "),r("li",[e._v("React15是同步更新视图的，当DOM层级嵌套比较多时，可能页面会出现卡顿")]),e._v(" "),r("li",[e._v("React15无法实现异步可中断的更新，所以React决定重写架构")])])])}),[],!1,null,null,null);t.default=_.exports}}]);