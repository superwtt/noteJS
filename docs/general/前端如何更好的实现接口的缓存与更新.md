### 前端接口的缓存与更新

项目开发过程中，常常遇到数据列表的请求，当用户进行切换、返回、下一页等操作时都会请求接口，如果频繁切换，也就会导致接口频繁的请求，在数据基本没有什么变动的情况下，这样的做法明显是不合理的，会浪费网络资源。

#### 场景再现

![](https://oscimg.oschina.net/oscnet/up-297ded38b6cc0600d6856d1a008810c2adb.png)

如图：<br/>
1. 底部菜单栏分为“进行中”，“历史任务”两个tab，两个请求
2. 顶部二级菜单栏分为“最新任务”，“马上过期”，两个请求
3. 当用户频繁切换这四个tab栏时，将会不停的发送请求，界面会一直在loading和数据展示中闪烁切换
4. 这四个tab栏中的数据，短时间内是不会变化的，而是周期性变化
---

#### 解决方法
1. store存储数据
2. 接口请求复用
3. 前端加锁

---

#### 实践
1. store中心存储数据，每次ajax请求之前先去store获取数据，如果有直接返回，如果没有就请求接口获取数据列表
```javascript
// ajax请求部分
http.getData().then(data=>{
   userList = data; // 赋值
})
// 数据存储
import fetch from "fetch";

const EXPIRE_TIME = 60000; // 设置过期时间为1分钟

class StoreDataCenter{
    getData(){
        const isDataOverTime = StoreDataCenter.isOverTime();
        return isDataOverTime?null:StoreDataCenter.getData()  // 过期了 返回Null,没过期 返回数据
    }
    static isOverTime(){
       const data = storeDataCenter.getData();
       if(!data) return true; // 没有数据 超时

       const currentTime = new Date().getTime(); // 当前时间戳

       const overTime = (currentTime-cacheData.expire)/1000; // 获取当前时间与存储数据时间之差
       if(overTime>EXPIRE_TIME){
          StoreDataCenter.deleteData()
          return true
       }
       return false
    }
    static saveData(res){
      // 缓存数据 并且将当前时间戳存入 方便之后判断数据是否过期
      let data = {
        expire: new Date().getTime(),
        data: response.data
      }
    }
    static deleteData(){
      // 删除数据缓存
    }
}
// http层
let data = StoreDataCenetr.getData();
if(!data){
    fetch.get({
        url:"/getData"
    }).then(res=>{
        storeDataCenter.storeData()
        return storeDataCenter.getData()
    })
}
return data
```
+ 优点：直接有效的解决了频繁请求服务端的问题，并且代码简单，容易理解和实现
+ 缺点：对于数据列表会频繁改变的需求，这个方法就不能适用了，需要前端再增加一些交互，比如列表下拉刷新或者另外加一个刷新按钮用来更新数据

2. 接口请求复用，比如有两个独立的组件，使用了相同的一个接口，组件之间没有依赖，但是相同的请求希望只请求一次：第二个请求复用第一个请求返回的Promise即可
```javascript
import fetch from "fetch";

let promise = StoreDataCenetr.getData();

// 获取数据
getData(){
  if(!promise){
    promise = fetch.get({
        url:"/getData"
    }).then(res=>{
        
    }).catch(error=>{
      StoreDataCenetr.deleteData();
      return Promise.reject(error)
    })
  }
  return promise
}

// 页面请求
getData().then()
getData().then() // 第二次调用 先取得之前的promise
```

+ 优点：有效的解决了方案一同时发送两个请求会请求两次的问题
+ 缺点：多个api请求 还是要继续封装

3. 前端加锁

前端加锁，点击请求按钮之后，将按钮disable，直到请求有返回再将按钮去掉disable。没有按钮的话，加个flag，每次请求之前判断下flag上次请求是否有返回，有再发送下一次请求。或者函数节流

+ 优点：对于频繁切换菜单导致的频繁发送请求有效
+ 缺点：没有前端缓存

#### 参考链接
[OSCHINA](https://my.oschina.net/wsafight/blog/3040140)
