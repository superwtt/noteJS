
### redux、react-redux、redux-thunk、redux-saga的区别

#### redux
提供一个数据共享中心store，外部可以访问和修改，跟react没什么关系，也可以结合其他库使用。redux的三个原则：
+ 单一数据源
+ state是只读的
+ 使用纯函数进行修改

1. 安装
`npm install --save redux`

---

2. 在src目录下新建index.js 和 reducer.js
```js
// index.js中
import { createStore } from "redux";
import reducer from "./reducer";
const store = createStore(reducer);
export default store;

// reducer.js中
const defaultState = {
  inputValue: 'write something'
}
export default (state = defaultState, action)=>{
   return state 
}
```

---

3. 组件中使用
```js
import store from "./store/index"
//...
constructor(props){
  super(props)  
  this.state = store.getState()  
}
```

---

4. 触发action
```js
changeInputValue(){
  const action = {
      type: 'changeInput',
      value: e.target.value
  }  
}
```

---

5. 在reducer.js中更改值
```js
export default (state=defaultState,action)=>{
  if(action.type==='changeInput'){
    let newState = JSON.parse(JSON.stringify(state))
    newState.inputVlue = action.value
    return newState  
  }
  return state
}
```

---

6. 订阅state的变化
```js
// ...

constructor(props){
   super(props)
   store.subscribe(this.storeChange) 
}

storeChange(){
  this.setState(store.getState()) 
}
```

7. 不使用中间件发送请求
```js
// 1.0 组件里发送
componentDidMount(){
  axios.get('/api/todolist').then(res=>{
     const action = initListAction({
        type:'INIT_LIST_DATA',
        data: res.data 
     });
     store.dispatch(action) 
  }).catch(err=>{
     console.log(err)
  })
}
// 2.0 reducer处理
if(action.type==='INIT_LIST_DATA'){
  const newState=JSON.parse(JSON.stringify(state));
  newState.list=action.data;
  return newState;  
}

```

---

#### react-redux
+ redux的使用方式中，一个组件需要做的事情太多了，监听状态的改变、更新组件、派发action、渲染界面等等。
+ react-redux是为了让redux更好地适用于react而生的一个库，react-redux不能处理异步操作，只能dispatch对象的action而不能dispatch请求的action

1. 安装
2. 使用Provier将组件和store内的数据关联，那么Provider之间所有的组件都可以访问store里面的数据，Provider连接了store，TodoList组件就有能力获取store里面的内容
```js
import { Provider } from "react-redux"

<Provider store={store}>
  <TodoList />
</Provider>
```
---
3. connect连接器，TodoList组件通过connect方法获取store里面的数据，与store里面的数据做连接，连接规则：mapStateToProps，这个store就是state里的数据
```js
class TodoList extends React.Component{
   // ... 
}
const mapStateToProps = (state)=>{}
const mapDispatchToProps = (dispatch)=>{}

export default connect(mapStateToProps,mapDispatchToProps)(TodoList)
```
---
4. 使用react-redux发送ajax请求
`react-redux`不能处理异步操作，`store.dispatch`只能派发对象的action而不能派发请求的action
---

#### redux-thunk
`redux-thunk`是redux的中间件，它可以在redux中实现异步请求
+ 什么是中间件：中间件指的是action和store之间，派发一个action之后，到达reducer之前，进行一些额外的操作，以前的action只能是一个对象，现在action可以是一个方法了，调用异步接口的方法，解决了异步数据流的问题
+ `redux-thunk`是对`store.dispatch`方法的升级：
  + 当接收到对象时，依然传递给store，store传递给reducer进行数据处理
  + 当接收到函数时，不会直接传递给store，而是让函数先执行，函数执行完了，需要用到store的时候才传递store

1. 安装
`npm install redux thunk`

2. 激活redux-thunk
```js
import { createStore, compose, applyMiddleware } from "redux";
import reducer from "./reducer";
import thunk from "redux-thunk";

const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ?  window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__({}) : compose;
const store = createStore(reducer, composeEnhancers(
    applyMiddleware(thunk)
));

export default store;

```

3. 组件中的使用
```js
// 组件中
class TodoList extends React.Component{
   componentDidMount(){
      this.props.getList(); 
   }
}
const mapStateToProps = (state)=>{}
const mapDispatchToProps = (dispatch)=>{
  return {
     getList(){
       // 因为有了中间件，此时store.dispatch能够派发一个方法了 
       return dispatch(actionCreators.getList());
     } 
  }  
}

export default connect(mapStateToProps,mapDispatchToProps)(TodoList)

// actionCreator.js 中
const getList = ()=>{
   return (dispatch)=>{
     RecommendServices.getRecommend().then((res) => {
     if (res.code === ERR_OK) {
       dispatch({
         type: constants.GET_RECOMMEND_LIST,
         value: res.data.slider,
       });
     }
   });   
   } 
}

```

---

#### redux-saga

将ajax请求相关拆分到另一个文件中，在非常大型的项目中有一定的优势

1. 安装
`npm install --save redux-saga`

---

2. 激活
```js
import { createStore,applyMiddleware,compose } from 'redux'
import reducer from './reducer'
import createSagaMiddleware from 'redux-saga'
import TodoSagas from './sagas'

const sagaMiddleware = createSagaMiddleware()
const composeEnhancers =window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ?   window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__({}) : compose;
const enhancer = composeEnhancers(applyMiddleware(sagaMiddleware));  

const store = createStore(reducer,enhancer);
sagaMiddleware.run(TodoSagas)

export default store;
```

---

3. 异步请求
+ 创建saga.js
```js
import { call, put, takeEvery} from 'redux-saga/effects'
import {GET_INIT_LIST} from './actionTypes'
import {initListAction} from "./actionCreators";
import axios from 'axios';

function* fetchUser(){
  const res = yield axios.get('/api/todolist'); // 请求的返回结果保存在了res中
  const action = initListAction(res.data); // 创建action
  yield put(action); // 代替store.dispatch(action)
}

function* mySaga(){
  yield takeEvery(GET_INIT_LIST, fetchUser) 
}

export default mySaga;
```
+ actionCreator中
```js
//发送请求，根据返回数据得到列表项
export const initListAction = (data)=>({
   type:INIT_LIST_ITEM,
   data 
})

//获取初始列表的action
export const getInitList = () => ({
    type:GET_INIT_LIST
});
```

+ 在生命周期中使用
```js
componentDidMount(){
   const action = getInitList();
   store.dispatch(action); 
}
```

---

#### dva
`dva = react-router + redux + redux-saga`

1. 组件中的使用
```js
import { connect } from "dva";

class TestComponent extends React.Component {
   componentDidMount(){
      dispatch({
         type:'useCouponDetail/getList' 
      }) 
   } 
}

export default connect(({})=>({
  
}))(TestComponent)
```
---

2. model.js中
```js
export default {
   namespace:'useCouponDetail', // model的命名空间，整个应用的state，由多个小的model的state以namespace为key生成
   state:{ // 该命名空间下的数据池
       pageInfo:{}
   },
   effects:{// 副作用处理函数
     *getList({payload},{call,put}){
        yield put({
            type:'save',
            payload:{
                pageInfo: res.data
            }
        }) 
     }
   },
   reducers:{// 等同于redux里的reducer，接收action，同步更新state
       save(state, {payload}){
           return {...state,...payload}
       }
   }
}
```

3. 组件中直接从props中解构数据就可以

---

### 总结
1. redux只是一个数据共享库，react使用的话，在组件中需要完成很多工作，所以不是很采纳
2. react-redux是为了让redux更好的适用于react而生的，可以将组件拆分成容器组件和UI组件，容器组件负责逻辑，UI组件只负责渲染，store.dispatch只能派发对象，不能派发方法，所以无法发送ajax请求
3. redux-thunk是redux的中间件，在react-redux的基础上，改进了store.dispatch不能派发方法的问题
4. redux-saga跟redux-thunk类似，又将actionCreator里面的ahax请求拆分成新文件，适用于超大型项目
5. dva基于 redux 和 redux-saga 的数据流方案，简化了开发体验，可以算是一个轻量级的应用框架

如果我选的话，中小型项目会选择react-redux配合中间件redux-thunk，大型项目会选择dva