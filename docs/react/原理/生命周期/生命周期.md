### React中的生命周期有哪些
1. 定义：生命周期是指在某一时刻，组件会自动调用执行的函数
2. 组件的执行时期：
+ 挂载阶段mount：只有组件在第一次被挂载在页面的时候执行
  + `constructor`：初始化state对象，给自定义方法绑定this
  + ~~`componentWillMount`~~：组件即将被挂载到页面的时候执行，在`render`之前，还没有挂载DOM
  + `componentDidMount`：组件被挂载到页面之后执行，在`render`之后，已经挂载DOM

+ 更新阶段update：组件更新的时候执行
  + `shouldComponentUpdate`：组件更新之前执行，需要返回true/false，返回true表示需要更新组件，返回false表示不需要更新组件
  + ~~`componentWillUpdate`~~：组件更新之前执行，在`shouldComponentUpdate`之后执行，且`shouldComponentUpdate`返回true才执行，否则不执行
  + `render`
  + `getSnapshotBeforeUpdate`：在render之后，componentDidUpdate之前调用
  + `componentDidUpdate`：组件更新完成之后执行
  + ~~`componentWillReceiveProps`~~：当一个组件从父组件接收了参数，只要这个父组件的render函数被重新执行了，这个生命周期才执行


+ 卸载阶段unmount
  + `componentWillUnmount`：当这个组件即将从页面中剔除的时候执行

![](https://raw.githubusercontent.com/superwtt/MyFileRepository/main/image/React/生命周期.png)

---

### 执行次数
1. 只执行一次：`constructor`、`componentWillMount`、`componentDidMount`
2. 执行多次：`render`、子组件的`componentWillReceiveProps`、`componentWillUpdate`、`componentDidUpdate`
3. 有条件的执行：`componentWillUmmount`组件离开时才执行
4. 不执行的：根组件的`componentWillReceiveProps`，因为根组件没有父组件传值给根组件了

---

### 源码解析
① 源码目录：`react/packages/react-reconciler/src/ReactFiberBeginWork.js`

```javascript
function beginWork(
  current: Fiber | null,
  workInProgress: Fiber,
  renderLanes: Lanes
): Fiber | null {

  // update时：如果current存在可能存在优化路径，可以复用current（即上一次更新的Fiber节点）
  if (current !== null) {
    // ...省略

    // 复用current
    return bailoutOnAlreadyFinishedWork(
      current,
      workInProgress,
      renderLanes,
    );
  } else {
    didReceiveUpdate = false;
  }

  // mount时：根据tag不同，创建不同的子Fiber节点
  switch (workInProgress.tag) {
    case IndeterminateComponent: 
      // ...省略
    case LazyComponent: 
      // ...省略
    case FunctionComponent: 
      // ...省略
    case ClassComponent: 
      const Component = workInProgress.type;
      const unresolvedProps = workInProgress.pendingProps;
      const resolvedProps =
        workInProgress.elementType === Component
          ? unresolvedProps
          : resolveDefaultProps(Component, unresolvedProps);
      return updateClassComponent(
        current,
        workInProgress,
        Component,
        resolvedProps,
        renderExpirationTime,
      );
    case HostRoot:
      // ...省略
    case HostComponent:
      // ...省略
    case HostText:
      // ...省略
    // ...省略其他类型
  }
}
```

+ `beginWork`的工作是根据当前Fiber节点，创建子的Fiber节点
+ 根据不同的tag，创建不同的子Fiber节点

② 以`ClassComponent`为例，生命周期就发生在`ClassComponent`的`updateClassComponent`

```javascript
function updateClassComponent(
  current: Fiber | null,
  workInProgress: Fiber,
  Component: any,
  nextProps,
  renderExpirationTime: ExpirationTime,
) {
  let hasContext;
  if (isLegacyContextProvider(Component)) {
    hasContext = true;
    pushLegacyContextProvider(workInProgress);
  } else {
    hasContext = false;
  }
  prepareToReadContext(workInProgress, renderExpirationTime);

  const instance = workInProgress.stateNode;
  let shouldUpdate;
  if (instance === null) {
  
    // 打印constructor的地方
    constructClassInstance(
      workInProgress,
      Component,
      nextProps,
      renderExpirationTime,
    );

    // 打印componentWillMount的地方
    mountClassInstance(
      workInProgress,
      Component,
      nextProps,
      renderExpirationTime,
    );
    shouldUpdate = true;
  } else if (current === null) {
    // mount的时候，cueernt = null
    // In a resume, we'll already have an instance we can reuse.
    shouldUpdate = resumeMountClassInstance(
      workInProgress,
      Component,
      nextProps,
      renderExpirationTime,
    );
  } else {
    shouldUpdate = updateClassInstance(
      current,
      workInProgress,
      Component,
      nextProps,
      renderExpirationTime,
    );
  }

  // 打印render的地方
  const nextUnitOfWork = finishClassComponent(
    current,
    workInProgress,
    Component,
    shouldUpdate,
    hasContext,
    renderExpirationTime,
  );
  return nextUnitOfWork;
}

```

③ 进入到`mountClassInstance`会发现调用生命周期的地方：`callComponentWillMount`，调用了新的生命周期`getDerivedStateFromProps`

```javascript
function mountClassInstance(
  workInProgress: Fiber,
  ctor: any,
  newProps: any,
  renderExpirationTime: ExpirationTime,
): void {

  const instance = workInProgress.stateNode;
  instance.props = newProps;
  instance.state = workInProgress.memoizedState;
  instance.refs = emptyRefsObject;

  const contextType = ctor.contextType;
  if (typeof contextType === 'object' && contextType !== null) {
    instance.context = readContext(contextType);
  } else {
    const unmaskedContext = getUnmaskedContext(workInProgress, ctor, true);
    instance.context = getMaskedContext(workInProgress, unmaskedContext);
  }

  let updateQueue = workInProgress.updateQueue;
  if (updateQueue !== null) {
    processUpdateQueue(
      workInProgress,
      updateQueue,
      newProps,
      instance,
      renderExpirationTime,
    );
    instance.state = workInProgress.memoizedState;
  }

  const getDerivedStateFromProps = ctor.getDerivedStateFromProps;
  if (typeof getDerivedStateFromProps === 'function') {
    applyDerivedStateFromProps(
      workInProgress,
      ctor,
      getDerivedStateFromProps,
      newProps,
    );
    instance.state = workInProgress.memoizedState;
  }

  // In order to support react-lifecycles-compat polyfilled components,
  // Unsafe lifecycles should not be invoked for components using the new APIs.
  if (
    typeof ctor.getDerivedStateFromProps !== 'function' &&
    typeof instance.getSnapshotBeforeUpdate !== 'function' &&
    (typeof instance.UNSAFE_componentWillMount === 'function' ||
      typeof instance.componentWillMount === 'function')
  ) {
    callComponentWillMount(workInProgress, instance);
    // If we had additional state updates during this life-cycle, let's
    // process them now.
    updateQueue = workInProgress.updateQueue;
    if (updateQueue !== null) {
      processUpdateQueue(
        workInProgress,
        updateQueue,
        newProps,
        instance,
        renderExpirationTime,
      );
      instance.state = workInProgress.memoizedState;
    }
  }

  if (typeof instance.componentDidMount === 'function') {
    workInProgress.effectTag |= Update;
  }
}
```

④ 进入`callComponentWillMount`，调用了`componentWillMount`周期

```javascript
function callComponentWillMount(workInProgress, instance) {
  startPhaseTimer(workInProgress, 'componentWillMount');
  const oldState = instance.state;

  if (typeof instance.componentWillMount === 'function') {
    instance.componentWillMount();
  }
  if (typeof instance.UNSAFE_componentWillMount === 'function') {
    instance.UNSAFE_componentWillMount();
  }

  stopPhaseTimer();

  if (oldState !== instance.state) {
    classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
  }
}
```


⑤ 对于我们常见的组件类型，如`FunctionComponent/ClassComponent/HostComponent`，最终都会进入`reconcilerChildren`方法，这个方法究竟做了什么呢？
+ 对于`mount`的组件，它会创建新的`子fiber节点`
+ 对于`update`组件，它会将当前组件与该组件在上次更新时对应的fiber节点比较，也就是俗称的diff算法，将比较的结果生成新的fiber节点

---

⑥ `completeWork`阶段会执行didMount类的生命周期函数，commit阶段可以分为三个子阶段：
+ before mutation（执行DOM操作前）：调用getSnapshotBeforeUpdate、 调度useEffect
+ mutation阶段（执行DOM操作）
+ layout阶段（执行DOM操作后）
```javascript
function completeRoot(
  // ...
  runWithPriority(ImmediatePriority, () => {
    commitRoot(root, finishedWork);
  });
}
```
 
⑦ 提交`commitLifeCycles`

```javascript
function commitLifeCycles(
  finishedRoot: FiberRoot,
  current: Fiber | null,
  finishedWork: Fiber,
  committedExpirationTime: ExpirationTime,
): void {
  switch (finishedWork.tag) {
    case FunctionComponent:
    case ForwardRef:
    case SimpleMemoComponent: {
      commitHookEffectList(UnmountLayout, MountLayout, finishedWork);
      break;
    }
    case ClassComponent: {
      const instance = finishedWork.stateNode;
      if (finishedWork.effectTag & Update) {
        if (current === null) {
          startPhaseTimer(finishedWork, 'componentDidMount');
          instance.componentDidMount();    // 执行componentDidMount方法
          stopPhaseTimer();
        } else {
          const prevProps =
            finishedWork.elementType === finishedWork.type
              ? current.memoizedProps
              : resolveDefaultProps(finishedWork.type, current.memoizedProps);
          const prevState = current.memoizedState;
          startPhaseTimer(finishedWork, 'componentDidUpdate');

          instance.componentDidUpdate(
            prevProps,
            prevState,
            instance.__reactInternalSnapshotBeforeUpdate,
          );
          stopPhaseTimer();
        }
      }
      const updateQueue = finishedWork.updateQueue;
      if (updateQueue !== null) {
        if (__DEV__) {
          if (
            finishedWork.type === finishedWork.elementType &&
            !didWarnAboutReassigningProps
          ) {
            warning(
              instance.props === finishedWork.memoizedProps,
              'Expected %s props to match memoized props before ' +
                'processing the update queue. ' +
                'This might either be because of a bug in React, or because ' +
                'a component reassigns its own `this.props`. ' +
                'Please file an issue.',
              getComponentName(finishedWork.type) || 'instance',
            );
            warning(
              instance.state === finishedWork.memoizedState,
              'Expected %s state to match memoized state before ' +
                'processing the update queue. ' +
                'This might either be because of a bug in React, or because ' +
                'a component reassigns its own `this.props`. ' +
                'Please file an issue.',
              getComponentName(finishedWork.type) || 'instance',
            );
          }
        }
        // We could update instance props and state here,
        // but instead we rely on them being set during last render.
        // TODO: revisit this when we implement resuming.
        commitUpdateQueue(
          finishedWork,
          updateQueue,
          instance,
          committedExpirationTime,
        );
      }
      return;
    }
    case HostRoot: {
      const updateQueue = finishedWork.updateQueue;
      if (updateQueue !== null) {
        let instance = null;
        if (finishedWork.child !== null) {
          switch (finishedWork.child.tag) {
            case HostComponent:
              instance = getPublicInstance(finishedWork.child.stateNode);
              break;
            case ClassComponent:
              instance = finishedWork.child.stateNode;
              break;
          }
        }
        commitUpdateQueue(
          finishedWork,
          updateQueue,
          instance,
          committedExpirationTime,
        );
      }
      return;
    }
    case HostComponent: {
      const instance: Instance = finishedWork.stateNode;

      // Renderers may schedule work to be done after host components are mounted
      // (eg DOM renderer may schedule auto-focus for inputs and form controls).
      // These effects should only be committed when components are first mounted,
      // aka when there is no current/alternate.
      if (current === null && finishedWork.effectTag & Update) {
        const type = finishedWork.type;
        const props = finishedWork.memoizedProps;
        commitMount(instance, type, props, finishedWork);
      }

      return;
    }
    case HostText: {
      // We have no life-cycles associated with text.
      return;
    }
    case HostPortal: {
      // We have no life-cycles associated with portals.
      return;
    }
    case Profiler: {
      if (enableProfilerTimer) {
        const onRender = finishedWork.memoizedProps.onRender;

        if (enableSchedulerTracing) {
          onRender(
            finishedWork.memoizedProps.id,
            current === null ? 'mount' : 'update',
            finishedWork.actualDuration,
            finishedWork.treeBaseDuration,
            finishedWork.actualStartTime,
            getCommitTime(),
            finishedRoot.memoizedInteractions,
          );
        } else {
          onRender(
            finishedWork.memoizedProps.id,
            current === null ? 'mount' : 'update',
            finishedWork.actualDuration,
            finishedWork.treeBaseDuration,
            finishedWork.actualStartTime,
            getCommitTime(),
          );
        }
      }
      return;
    }
    case SuspenseComponent:
      break;
    case IncompleteClassComponent:
      break;
    default: {
      invariant(
        false,
        'This unit of work tag should not have side-effects. This error is ' +
          'likely caused by a bug in React. Please file an issue.',
      );
    }
  }
}

```

---

### 废弃的以及新增的生命周期
1.废弃的
+ `componentWillMount`
+ `componentWillReceiveProps`
+ `componentWillUpdate`


2.新增的
+ `static getDerivedStateFromProps`：当我们接收到新的属性想去修改我们的state，可以在这个生命周期中完成
+ `getSnapshotBeforeUpdate`

---

### 异步渲染的两个阶段
1.`Reconciliation阶段`
+ `componentWillMount`
+ `componentWillReceiveProps`
+ `shouldComponentUpdate`
+ `componentWillUpdate`

2.`Commit`阶段
+ `componentDidMount`
+ `componentDidUpdate`
+ `componentWillUnMount`

---

https://developer.aliyun.com/article/72330
