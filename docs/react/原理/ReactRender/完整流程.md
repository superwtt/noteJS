### ReactDOM.render的完整流程
#### 1. 创建fiber
从双缓存机制一节我们知道，首次执行`ReactDOM.render`会创建`fiberRootNode`和`rootFiber`，其中`fiberRootNode`是整个应用的根节点，`rootFiber`是要渲染的组件所在组件树的根节点

① 这一步发生在调用`ReactDOM.render`后进入的`legacyRenderSubtreeIntoContainer`方法中

```js
root = container._reactRootContainer = legacyCreateRootFromDOMContainer(
   container,
   forceHydrate,
);
fiberRoot = root._internalRoot;
```

② `legacyCreateRootFromDOMContainer`方法内部会调用`createFiberRoot`方法完成`fiberRootNode`和`rootFiber`的创建以及关联，并初始化`updateQueue`

```js
export function createFiberRoot(
  containerInfo: any,
  tag: RootTag,
  hydrate: boolean,
  hydrationCallbacks: null | SuspenseHydrationCallbacks,
): FiberRoot {
  // 创建fiberRootNode
  const root: FiberRoot = (new FiberRootNode(containerInfo, tag, hydrate): any);
  
  // 创建rootFiber
  const uninitializedFiber = createHostRootFiber(tag);

  // 连接rootFiber与fiberRootNode
  root.current = uninitializedFiber;
  uninitializedFiber.stateNode = root;

  // 初始化updateQueue
  initializeUpdateQueue(uninitializedFiber);

  return root;
}
```

根据以上代码，我们可以在双缓存机制一节基础上补充上`rootFiber`到`fiberRootNode`的引用

![](https://raw.githubusercontent.com/superwtt/MyFileRepository/main/image/React/fiberroot.png)

#### 2. 创建update

我们已经做好了组件的初始化工作，接下来就是等待创建`Update`来开启一次更新

这一步发生在`updateContainer`方法中

```js
export function updateContainer(
  element: ReactNodeList,
  container: OpaqueRoot,
  parentComponent: ?React$Component<any, any>,
  callback: ?Function,
): Lane {
  // ...省略与逻辑不相关代码

  // 创建update
  const update = createUpdate(eventTime, lane, suspenseConfig);
  
  // update.payload为需要挂载在根节点的组件
  update.payload = {element};

  // callback为ReactDOM.render的第三个参数 —— 回调函数
  callback = callback === undefined ? null : callback;
  if (callback !== null) {
    update.callback = callback;
  }

  // 将生成的update加入updateQueue
  enqueueUpdate(current, update);
  // 调度更新
  scheduleUpdateOnFiber(current, lane, eventTime);

  // ...省略与逻辑不相关代码
}
```

#### 3. 流程概览

至此，`ReactDOM.render`的流程就和我们已知的流程链接上了，整个流程如下：

```js
创建fiberRootNode、rootFiber、updateQueue（`legacyCreateRootFromDOMContainer`）

    |
    |
    v

创建Update对象（`updateContainer`）

    |
    |
    v

从fiber到root（`markUpdateLaneFromFiberToRoot`）
// 从触发更新的fiber一直向上遍历到`rootFiber`，并返回`rootFiber`，这样我们就得到了整个应用的根节点

    |
    |
    v

调度更新（`ensureRootIsScheduled`）

    |
    |
    v

render阶段（`performSyncWorkOnRoot` 或 `performConcurrentWorkOnRoot`）

    |
    |
    v

commit阶段（`commitRoot`）
```