### React Reconciliation
1. 定义：每次`render`的时候，React都会产生一棵由React元素组成的树，这个树形结构就是所谓的虚拟DOM，下次`render`的时候又会产生一个新的树，对比着两棵树的不同的过程，就是协调（调和），即`Reconciliation`

---

### 调和的目的
`Reconciliation`的目的是跟踪组件状态的变化，在用户无感知的情况下将数据的更新体现到UI上

---

### 对比过程分类
1.根节点类型不同的情况
+ 如果根节点类型不同，如下的`div`变成了`span`，那么对比的开销太大了，所以React选择了重建，会将原有的树卸载，再将新的树装载
  ```javascript
  <div>
    <Counter />
  </div>
  <span>
    <Counter />
  </span>
  ```

2.根节点类型相同的情况
+ 如果是根节点相同的情况下，只会更改有变化的部分
  + 当节点类型是HTML元素类型时（如`span`、`p`、`div`等），如下，只会更改color变化的值和div里变化的值
  ```javascript
   <div style={{color:'red',fontWeight:'bold'}}>Hello world</div>
   <div style={{color:'green',fontWeight:'bold'}}>good bye</div>
  ```
  + 当节点类型是React组件类型时,React并不知道如何去更新DOM，这些逻辑在React组件当中，所以只能去更新props的值，引发这个组件的更新过程，实现对子元素的递归
  ```javascript
  <Todo text="old">
  <Todo text="new">
  ```

3.多个同级元素的情况
+ 如果是在最下方插入，那么情况没那么糟糕，React会去对比每一个元素，first对比first，second对比second，然后发现多了一个third，那么就在原有的基础上加上这个元素
```javascript
<ul>
  <li>first</li>
  <li>second</li>
</ul>
// 在下方插入
<ul>
  <li>first</li>
  <li>second</li>
  <li>third</li>
</ul>
```

+ 如果是在最上方插入，那么对比的开销就很大了，first对比third，second对比first，然后发现多了一个second，这样的话，本来只是新增一个元素的情况，会变成全部元素都要修改
```javascript
<ul>
  <li key={1}>first</li>
  <li key={2}>second</li>
</ul>
// 在上方插入
<ul>
  <li key={1}>third</li>
  <li key={2}>first</li>
  <li key={3}>second</li>
</ul>
```
解决这个问题的唯一方法就是给元素设置唯一的`key`，如果用Index作为key，那么原先1代表的是first，现在代表的是third，那么又要重新渲染，失去了key的意义










---
### 参考链接
https://zhuanlan.zhihu.com/p/59055212
