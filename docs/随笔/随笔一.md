#### js function this的作用
#### React class类组件的写法到底是什么意思：https://segmentfault.com/a/1190000003046071
1. 普通函数调用
2. 作为对象的方法
3. 作为构造函数来调用
4. new 操作符，this指向新创建的对象
5. call/apply方法的调用
6. Function.prototype.bind()方法
7. Eval函数，该函数执行的时候，this绑定到当前作用域的对象上
8. 箭头函数，this的值与创建箭头函数的上下文的this一致

#### render()函数在组件中的作用是什么
render函数是react组件lifecycle的一部分，其中ReactDOM是一个类对象，它公开一个名为render的方法，将React JSX呈现到DOM中。
一般情况下，我们可以在App中使用ReactDOM.render一次渲染顶级组件，所有其他组件将是顶级组件的子级

#### react和react-dom的关系
React在v0.14之前，是没有react-dom的，所有的功能都包含在react里。从v0.14(2015-10)开始，react才被拆分成react和react-dom。
为什么要把react和react-dom分开呢？因为有了react-native。react只包含了Web和Mobile通用的核心部分，负责DOM操作的分到了react-dom中，负责Mobile的包含在了react-native中。

ReactDOM只做和浏览器或DOM相关的操作，例如ReactDOM.render()和ReactDOM.findDOMNode()，如果是服务器渲染，可以使用ReactDOM.renderToString()。除了这些以外的其他所有事情都是react做的。

（有些业务场景是没有dom的，就不需要使用dom的操作；关于dom的就放在dom里面，关于手机端的就放在native里，就是不同层级模块之间不能完全依赖）

#### HashRouter, Link, Route之间的关系
1. Link是怎么切换路由的呢？就是通过this.props.history.push(path)来改变HashRouter中的pathname属性，进而驱动Route们进行重新渲染，再次匹配我们的路由，最终实现路由的切换。渲染
成一个a标签，然后给一个点击事件，点击的时候更改HashRouter的状态，驱动重新渲染
2. HashRouter是一个大容器，它控制着他自己到底渲染成什么样子，它是通过window.location.hash。当HashRouter开始渲染的时候，就会拿自己身上的pathname属性跟它肚子里Route的path进行匹配，
匹配上的话，就会渲染Route的component对应的组件
3. Redirect 就是改变HashRouter的state，驱动重新渲染
4. https://juejin.cn/post/6844903588603363341


#### state,props,context
1. state: 维护组件内部“产生数据”的信息
2. props: 维护组件外部“传入数据”的信息
3. context: 维护跨级组件信息的传递，把数据放在一个“全局的云端”，需要的地方直接拿来用就可以。但是耦合性高，安全性低，可以随意修改
   3.0 context属性的使用步骤 
   3.1 【准备步骤】
     3.1.1 在产生参数的最顶级组件中，使用childContextTypes静态属性来定义需要放入全局参数的类型
     3.1.2 在父组件中，提供状态，来管理数据
     3.1.3 声明子组件获取全局参数的方式
     class App {
         static childContextTypes = {
             title: ProTypes.string
         }
         state = {
             title:'源码TV'
         }
         getChildContext(){
             return {
                 title: this.state.title
             }
         }
     }
   3.2 【使用步骤】
     3.2.1 在子组件中，使用contextTypes静态属性，声明获取父组件放入全局context中的参数类型
     3.2.2 在子组件需要的地方，获取全局参数this.context.全局属性名
     class Child{
         static contextTypes = {
             title:ProTypes.string
         }
         render(){
             return (
                 <div>{this.context.title}</div>
             )
         }
     }
   

4. 传统应用的弊端就是，跨级数据传递就是用props，一级一级往下传，每层都必须准确的把数据往下传，


#### redux
1. store 相当于一个商店，里面有很多货架：维持应用的state、getState()、dispatch(action)、subscribe(listener)


#### react组件的渲染时机
1. 调用了setState，使得状态改变了
2. props发生了变化
3. 


#### recommend首页获取轮播图和歌单列表做缓存


