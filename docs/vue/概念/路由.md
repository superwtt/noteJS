### hash路由

#### 定义

hash指的是地址中#号以及后面的字符，hash也称为锚点，是用来做页面跳转定位的，如`http://localhost/index.html#abc`，这里的`#abc`就是hash

---

#### 注意点
+ hash值是不会随着请求发送到服务端的，所以改变hash值，不会重新加载页面
+ `window.onhashchange`可以监听到页面hash值的变化
+ `location.hash`可以用来获取和设置hash值，并且hash值的改变会直接反映到浏览器的地址栏

---

### history路由
利用H5 History Interface中新增的两个API `pushState()` 和 `replaceState()`，以及事件的`onpopstate`监听URL的变化。

History api可以分为两大部分：切换和修改

（1）切换：切换历史状态包括`back`、`forward`、`go`三个方法，对应浏览器的前进、后退、跳转操作
```js
history.go(-2); // 后退两次
history.go(2); // 前进两次
history.back(); // 后退
history.forward(); // 前进
```

（2）修改：修改历史状态包括`pushState`、`replaceState`两个方法，接收三个参数：
+ stateObj：一个对象，可以通过`history.state`取到，可以将对象内容传递到新页面中，如果不需要这个对象，可以填null
+ title：标题，几乎没有浏览器支持该参数，传一个空字符串比较安全
+ url：新的网址，必须与当前页面处于同一个域，如果设置了一个跨域网址，则会报错

---

### 如何选择使用？
一般情况下，hash和history都可以，除非你更在意颜值，#夹杂在url中确实不太美观。如果不想要很丑的hash值，我们可以选择history模式，该模式充分利用了history.pushState API来完成url重新跳转而无须重新加载页面

---

### 区别
1. hash模式下，仅#之前的内容会被包含在请求中，如`http://www.abc.com`，因此对于后端来说，即使没有做到路由全覆盖，也不会返回404错误
2. history模式下，前端的url必须和实际向后端发起请求的url一致，如`http://www.abc.com/book/id`，如果后端缺少对`/book/id`的处理，将返回404错误。这种模式要玩好，需要后端配置的支持。需要后端在服务端增加一个覆盖所有情况的候选资源：如果URL匹配到任何资源，则应该返回一个默认的配置页面
3. Vue中路由传参有query和params两种方式，params方式：'/xx:id'，在刷新之后参数会丢失